# Artistic Style stylefile

#
# Tab Options
#

# Indentation with 4 spaces
--indent=tab


#
# Bracket Modify Options
#

# Attach brackets to a namespace statement. This is done regardless of the
# bracket style being used.
--attach-namespaces

# Attach brackets to a class statement. This is done regardless of the bracket
# style being used.
--attach-classes

# Attach brackets to class and struct inline function definitions. This is not
# done for run-in type brackets (Horstmann and Pico styles). This option is
# effective for C++ files only.
--attach-inlines

# Attach brackets to a bracketed extern "C" statement. This is done regardless
# of the bracket style being used. This option is effective for C++ files only.
# An extern "C" statement that is part of a function definition is formatted
# according to the requested bracket style. Bracketed extern "C" statements are
# unaffected by the bracket style and this option is the only way to change
# them.
--attach-extern-c


#
# Indentation Options
#

# Indent 'class' and 'struct' blocks so that the entire block is indented. The
# struct blocks are indented only if an access modifier, 'public:', 'protected:'
# or 'private:', is declared somewhere in the struct. This option is effective
# for C++ files.
--indent-classes

# Indent 'class' and 'struct' access modifiers, 'public:', 'protected:' and
# 'private:', one half indent. The rest of the class is not indented. This
# option is effective for C++ files only. If used with indent‑classes this
# option will be ignored.
# --indent-modifiers

# Indent 'switch' blocks so that the 'case X:' statements are indented in the
# switch block. The entire case block is indented.
--indent-switches

# Indent 'case X:' blocks from the 'case X:' headers. Case statements not
# enclosed in blocks are NOT indented.
--indent-cases

# Add extra indentation to namespace blocks. This option has no effect on Java
# files.
--indent-namespaces

# Add extra indentation to labels so they appear 1 indent less than the current
# indentation, rather than being flushed to the left (the default).
--indent-labels

# Indent preprocessor blocks at bracket level zero, and immediately within a
# namespace. There are restrictions on what will be indented. Blocks within
# methods, classes, arrays, etc, will not be indented. Blocks containing
# brackets or multi-line define statements will not be indented. Without this
# option the preprocessor block is not indented.
# --indent-preproc-block

# Indent multi-line preprocessor definitions ending with a backslash. Should be
# used with --convert-tabs for proper results. Does a pretty good job, but
# cannot perform miracles in obfuscated preprocessor definitions. Without this
# option the preprocessor statements remain unchanged.
--indent-preproc-define

# Indent preprocessor conditional statements to the same level as the source
# code.
--indent-preproc-cond


#
# Padding Options
#

# Pad empty lines around header blocks (e.g. 'if', 'for', 'while'...). Treat
# closing header blocks (e.g. 'else', 'catch') as stand-alone blocks.
--break-blocks=all

# Insert space padding around operators. Any end of line comments will remain in
# the original column, if possible. Note that there is no option to unpad. Once
# padded, they stay padded.
--pad-oper

# Insert space padding between a header (e.g. 'if', 'for', 'while'...) and the
# following paren. Any end of line comments will remain in the original column,
# if possible. This can be used with unpad-paren to remove unwanted spaces.
--pad-header

# Remove extra space padding around parenthesis on the inside and outside. Any
# end of line comments will remain in the original column, if possible. This
# option can be used in combination with the paren padding options pad‑paren,
# pad‑paren‑out, pad‑paren‑in, and pad‑header above. Only padding that has not
# been requested by other options will be removed.
#
# For example, if a source has parens padded on both the inside and outside, and
# you want inside only. You need to use unpad-paren to remove the outside
# padding, and pad‑paren‑in to retain the inside padding. Using only
# pad‑paren‑in would not remove the outside padding.
--unpad-paren

# Attach a pointer or reference operator (*, &, or ^) to either the variable
# type (left) or variable name (right), or place it between the type and name
# (middle). The spacing between the type and name will be preserved, if
# possible. This option is for C/C++, C++/CLI, and C# files. To format
# references separately use the following align-reference option.
--align-pointer=name

# This option will align references separate from pointers. Pointers are not
# changed by this option. If pointers and references are to be aligned the same,
# use the previous align-pointer option. The option align-reference=none will
# not change the reference alignment. The other options are the same as for
# align-pointer. This option is for C/C++, C++/CLI, and C# files.
--align-reference=name


#
# Formatting Options
#

# Remove brackets from conditional statements (e.g. 'if', 'for', 'while'...).
# The statement must be a single statement on a single line. If --add-brackets
# or --add-one-line-brackets is also used the result will be to add brackets.
# Brackets will not be removed from "One True Brace Style", --style=1tbs.
--remove-brackets

# Converts tabs into spaces in the non-indentation part of the line. The number
# of spaces inserted will maintain the spacing of the tab. The current setting
# for spaces per tab is used. It may not produce the expected results if
# convert-tabs is used when changing spaces per tab. Tabs are not replaced in
# quotes.
--convert-tabs

# Closes whitespace in the angle brackets of template definitions. Closing the
# ending angle brackets is now allowed by the C++11 standard. Be sure your
# compiler supports this before making the changes.
# --close-templates

# The option max‑code‑length will break a line if the code exceeds # characters.
# The valid values are 50 thru 200. Lines without logical conditionals will
# break on a logical conditional (||, &&, ...), comma, paren, semicolon, or
# space.
#
# Some code will not be broken, such as comments, quotes, and arrays. If used
# with keep‑one‑line‑blocks or add-one-line-brackets the blocks will NOT be
# broken. If used with keep‑one‑line‑statements the statements will be broken at
# a semicolon if the line goes over the maximum length. If there is no available
# break point within the max code length, the line will be broken at the first
# available break point after the max code length.
#
# By default logical conditionals will be placed first on the new line. The
# option break‑after‑logical will cause the logical conditionals to be placed
# last on the previous line. This option has no effect without max‑code‑length.
--max-code-length=80
--break-after-logical


#
# Other Options
#

# Do not retain a backup of the original file. The original file is purged after
# it is formatted.
--suffix=none

# Preserve the original file's date and time modified. The time modified will be
# changed a few micro seconds to force the changed files to compile. This option
# is not effective if redirection is used to rename the input file.
--preserve-date

# Force use of the specified line end style. Valid options are windows (CRLF),
# linux (LF), and macold (CR). MacOld style is the format for Mac OS 9 and
# earlier. OS X uses the Linux style. If one of these options is not used the
# line ends will be determined automatically from the input file.
--lineend=linux
